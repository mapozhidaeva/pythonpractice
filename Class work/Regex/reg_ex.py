import re

s = '<<совесть>>!'

if re.search('.', s):
    print (s)


# совест. -
# квантификаторы: ? .+ (если поставлен после точки, означает >= 1 раз, но точка
# работает только до конца строки) .* (означает 0 или более раз)
# .{1,2} - заданное количество или диапозон
# - после совест. может быть совести, совестью
# символьгый класс - создается с помощью []: [её] 'Г[её]те'
# но можно еще так: 'Го?(е|ё)те'
# [а-я] но надо дописать букву ё: [а-яёА-ЯЁ]
# экранировать: [\-], либо поставить в конец: [а-яёА-ЯЁ-]
# \[.?]
# .+о (любой симфол, 1 или более раз, буквы о) - мо, ло, ко, моло, молоко
# но найдется только слово молоко полностью (наибольшее значение, или жадность)
#мы можем ограничить жадность квантификатора
# это делается с помощью знака вопроса: +?j = 1
#
#
#
#
#if re.search('<<.+?>>', s):
if re.search('<+', s):
    print(s)

r = re.search('<<(.+?)>>'):

#метод gpoup
if r:
    word = r.group(1)

# в регулярных выражениях нумерация с 1
# search сработает только 1 раз, поэтому иногда можно использовать findall
# a = re.findall(regex, s)
# s = re.sub("[а-я]", "1", s)
# мы хотим хитро заменит одно слолво на другое: кириллица, перед запятой или
# точка с запятой
# \1 это ссылка на 1 группу
# s = re.sub("[а-я]+?(,|:)", "a\1", s)
# s = re.sub("(о|е)р(у|ю)", r"\2р\1", s)
# regexp = re.compile ("[а-я]+?<<")
# r = regexp.search(s)
# a = regexp.findall(s)
# s = regexp.sub("abc", s)



